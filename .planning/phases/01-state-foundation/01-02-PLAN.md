---
phase: 01-state-foundation
plan: 02
type: execute
---

<objective>
Implement step data model with registration and query functions for tracking setup step execution status.

Purpose: Enable the setup system to track individual step completion, including metadata like kind (automated/manual), subtype (brew/brew-cask/mac-defaults/other), and timestamps. This builds on the state file utilities from 01-01 to provide step-level granularity.
Output: Extended lib/state.sh with step functions (register, get-status, is-complete, mark-complete) and JSON structure with "steps" key.
</objective>

<execution_context>
@~/.claude/skills/create-plans/workflows/execute-phase.md
@~/.claude/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/01-state-foundation/01-01-SUMMARY.md
@lib/state.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define step schema and add step_register function</name>
  <files>lib/state.sh</files>
  <action>Add step_register function that creates/updates a step entry in state.json under a "steps" object. Function signature: step_register(step_id, description, kind, subtype). Fields: id (unique identifier), description (human-readable), kind (automated|manual), subtype (brew|brew-cask|mac-defaults|other), status (pending|complete), timestamp (ISO8601 when marked complete, empty when pending). Use jq to merge the step into .steps[step_id] ensuring proper JSON structure. Initialize status as "pending" and timestamp as empty string. Validate kind is one of: automated, manual. Validate subtype is one of: brew, brew-cask, mac-defaults, other. Return 0 on success, 1 on validation failure with error message to stderr.</action>
  <verify>Source lib/state.sh and run: step_register "test-brew" "Install test package" "automated" "brew" && cat "$KYLDVS_PREFIX/state.json" | jq '.steps["test-brew"]' shows correct structure with status="pending"</verify>
  <done>step_register function exists, creates proper JSON structure under .steps[id], validates inputs, and returns appropriate exit codes</done>
</task>

<task type="auto">
  <name>Task 2: Add step_get_status function</name>
  <files>lib/state.sh</files>
  <action>Add step_get_status function that retrieves the status field for a given step_id. Function signature: step_get_status(step_id). Use jq to query .steps[step_id].status from state.json. Return the status string to stdout ("pending" or "complete"). If step doesn't exist, return empty string and exit code 1. Return exit code 0 on success. This function is used by wrapper scripts to check if a step should be skipped.</action>
  <verify>After registering a test step, run step_get_status "test-brew" and verify it outputs "pending" and returns exit code 0. Try step_get_status "nonexistent" and verify it outputs nothing and returns exit code 1.</verify>
  <done>step_get_status retrieves status correctly, returns empty string for missing steps, and has proper exit codes</done>
</task>

<task type="auto">
  <name>Task 3: Add step_is_complete function</name>
  <files>lib/state.sh</files>
  <action>Add step_is_complete function that returns boolean exit code for step completion status. Function signature: step_is_complete(step_id). Use step_get_status internally to get status. Return exit code 0 (true) if status is "complete", exit code 1 (false) otherwise (including missing step). This provides a clean boolean check for shell if statements: if step_is_complete "my-step"; then skip; fi</action>
  <verify>Register a test step, verify step_is_complete returns 1 (false). Mark it complete (using jq directly for now), verify step_is_complete returns 0 (true).</verify>
  <done>step_is_complete returns correct exit codes, works in if statements, handles missing steps gracefully</done>
</task>

<task type="auto">
  <name>Task 4: Add step_mark_complete function</name>
  <files>lib/state.sh</files>
  <action>Add step_mark_complete function that updates a step's status to "complete" and records timestamp. Function signature: step_mark_complete(step_id). Use jq to update .steps[step_id].status to "complete" and .steps[step_id].timestamp to current ISO8601 timestamp (date -u +"%Y-%m-%dT%H:%M:%SZ" for UTC). If step doesn't exist, return exit code 1 with error message to stderr. Return exit code 0 on success. This function is called by wrapper scripts after successful step execution.</action>
  <verify>Register a test step, call step_mark_complete "test-brew", then verify status is "complete" and timestamp is populated with valid ISO8601 format using jq query</verify>
  <done>step_mark_complete updates status and timestamp, handles missing steps, returns proper exit codes</done>
</task>

<task type="auto">
  <name>Task 5: Test complete step lifecycle</name>
  <files>lib/state.sh</files>
  <action>Create a comprehensive test that exercises the full step lifecycle: 1) Initialize state, 2) Register multiple steps with different kinds/subtypes, 3) Verify all start as pending, 4) Mark some complete, 5) Verify status changes and timestamps exist, 6) Test error cases (invalid kind/subtype, missing step operations). This can be done by adding test commands in comments at the end of state.sh or creating a simple test script in lib/test_state.sh. The test should demonstrate all four functions working together correctly.</action>
  <verify>Run the lifecycle test and verify all assertions pass: registration succeeds, status queries return correct values, completion marking works, error cases fail appropriately</verify>
  <done>Complete step lifecycle works end-to-end with all functions integrated correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All four step functions exist in lib/state.sh (step_register, step_get_status, step_is_complete, step_mark_complete)
- [ ] JSON structure uses .steps object with step_id as keys
- [ ] Input validation works for kind and subtype enums
- [ ] Lifecycle test demonstrates all functions working together
- [ ] No shell syntax errors: bash -n lib/state.sh succeeds
</verification>

<success_criteria>
- All tasks completed with working implementations
- Step functions integrate cleanly with state.json structure from 01-01
- Error handling and validation work correctly
- Complete step lifecycle verified through testing
- Ready for Phase 2 step integration work
</success_criteria>

<output>
After completion, create `.planning/phases/01-state-foundation/01-02-SUMMARY.md`:

# Phase 1 Plan 2: Step Data Model Summary

**[Substantive one-liner describing what shipped - the step functions and data structure]**

## Accomplishments
- [Key function implementations]
- [JSON schema structure]
- [Validation and error handling]

## Files Created/Modified
- `lib/state.sh` - Added step_register, step_get_status, step_is_complete, step_mark_complete functions

## Decisions Made
[Any decisions about implementation details, or "None - followed plan as specified"]

## Deviations from Plan
[Document any auto-fixes, architectural changes, or deferred enhancements, or "None - plan executed exactly as written"]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Step
Ready for 02-01-PLAN.md (Phase 2: Step Integration)
</output>
