---
phase: 04-undo-capability
plan: 01
type: execute
---

<objective>
Implement undo functions for reversible step subtypes (brew, brew-cask, mac-defaults) to enable rolling back completed setup steps.

Purpose: Enable users to reverse automated setup changes, making the system more flexible and allowing experimentation without permanent consequences.

Output:
- Undo functions in state management library
- Ability to reverse brew installs, brew cask installs, and mac-defaults changes
- Error handling for undo operations
</objective>

<execution_context>
@~/.claude/skills/create-plans/workflows/execute-phase.md
@~/.claude/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@tasks/setup/justfile
</context>

<tasks>

<task id="1" type="auto">
<what>Create lib/state.sh with state file initialization function</what>

<why>Need a shell library to house all state management and undo functions in a centralized location</why>

<how>
1. Create lib/ directory if it doesn't exist
2. Create lib/state.sh with shebang and header comments
3. Implement init_state_file() function that:
   - Creates KYLDVS_PREFIX directory if needed
   - Initializes empty JSON state file at $KYLDVS_PREFIX/state.json if not exists
   - Uses jq to create valid JSON structure with steps array
4. Add helper functions:
   - get_state_file_path() - returns "$KYLDVS_PREFIX/state.json"
   - state_file_exists() - checks if state file exists
5. Document functions with comments explaining parameters and return values
</how>

<done>
- lib/state.sh exists with documented functions
- init_state_file() creates state.json with valid JSON structure
- Helper functions work correctly
</done>

<verify>
```bash
# Source the library
source lib/state.sh

# Test initialization
export KYLDVS_PREFIX="/tmp/test-kyldvs-$$"
init_state_file

# Verify file exists and has valid JSON
test -f "$KYLDVS_PREFIX/state.json"
jq empty "$KYLDVS_PREFIX/state.json"

# Cleanup
rm -rf "$KYLDVS_PREFIX"
```
</verify>
</task>

<task id="2" type="auto">
<what>Implement undo-brew function in lib/state.sh</what>

<why>Brew packages need to be uninstallable to reverse automated setup steps</why>

<how>
1. Add undo_brew() function to lib/state.sh that:
   - Accepts package name as parameter
   - Checks state.json to verify the step was completed
   - Retrieves original installation parameters from state
   - Executes: brew uninstall <package>
   - Handles errors gracefully (package not installed, brew error, etc.)
   - Updates state.json to mark step as undone
   - Returns 0 on success, non-zero on failure
2. Add logging for undo operations
3. Add validation that step exists and was completed before attempting undo
</how>

<done>
- undo_brew() function exists in lib/state.sh
- Function validates step was completed before undo
- Executes brew uninstall correctly
- Updates state to reflect undo operation
- Error handling for common failure cases
</done>

<verify>
```bash
source lib/state.sh

# Setup test state
export KYLDVS_PREFIX="/tmp/test-kyldvs-$$"
init_state_file

# Create mock completed state for cowsay
jq '.steps += [{"id": "brew-cowsay", "description": "Install cowsay", "kind": "automated", "subtype": "brew", "status": "completed", "params": {"package": "cowsay"}}]' "$KYLDVS_PREFIX/state.json" > "$KYLDVS_PREFIX/state.json.tmp"
mv "$KYLDVS_PREFIX/state.json.tmp" "$KYLDVS_PREFIX/state.json"

# Test that function exists and validates properly
if declare -f undo_brew > /dev/null; then
  echo "undo_brew function exists"
fi

# Test error handling for non-existent step
if ! undo_brew "nonexistent-package"; then
  echo "Correctly fails for non-existent package"
fi

# Cleanup
rm -rf "$KYLDVS_PREFIX"
```
</verify>
</task>

<task id="3" type="auto">
<what>Implement undo-brew-cask function in lib/state.sh</what>

<why>Brew cask applications need to be uninstallable separately from regular brew packages</why>

<how>
1. Add undo_brew_cask() function to lib/state.sh that:
   - Accepts cask name as parameter
   - Checks state.json to verify the step was completed
   - Retrieves original installation parameters from state
   - Executes: brew uninstall --cask <cask>
   - Handles errors gracefully (cask not installed, brew error, etc.)
   - Updates state.json to mark step as undone
   - Returns 0 on success, non-zero on failure
2. Add logging for undo operations
3. Add validation that step exists and was completed before attempting undo
4. Handle special case where cask may have files that require manual cleanup
</how>

<done>
- undo_brew_cask() function exists in lib/state.sh
- Function validates step was completed before undo
- Executes brew uninstall --cask correctly
- Updates state to reflect undo operation
- Error handling for common failure cases
- Warns user if manual cleanup may be needed
</done>

<verify>
```bash
source lib/state.sh

# Setup test state
export KYLDVS_PREFIX="/tmp/test-kyldvs-$$"
init_state_file

# Create mock completed state for a cask
jq '.steps += [{"id": "brew-cask-wezterm", "description": "Install WezTerm", "kind": "automated", "subtype": "brew-cask", "status": "completed", "params": {"cask": "wezterm"}}]' "$KYLDVS_PREFIX/state.json" > "$KYLDVS_PREFIX/state.json.tmp"
mv "$KYLDVS_PREFIX/state.json.tmp" "$KYLDVS_PREFIX/state.json"

# Test that function exists
if declare -f undo_brew_cask > /dev/null; then
  echo "undo_brew_cask function exists"
fi

# Test error handling for non-existent step
if ! undo_brew_cask "nonexistent-cask"; then
  echo "Correctly fails for non-existent cask"
fi

# Cleanup
rm -rf "$KYLDVS_PREFIX"
```
</verify>
</task>

<task id="4" type="auto">
<what>Implement undo-mac-defaults function in lib/state.sh</what>

<why>Mac system defaults changes need to be reversible to restore original settings</why>

<how>
1. Add undo_mac_defaults() function to lib/state.sh that:
   - Accepts domain and key as parameters
   - Checks state.json to verify the step was completed
   - Retrieves original value from state (captured during initial change)
   - Executes: defaults delete <domain> <key> (or restore original value if stored)
   - Handles errors gracefully (key not found, permission denied, etc.)
   - Restarts affected services (Dock, Finder, SystemUIServer) as needed
   - Updates state.json to mark step as undone
   - Returns 0 on success, non-zero on failure
2. Add optional parameter to restore original value instead of deleting
3. Add service restart logic based on domain (dock, finder, etc.)
4. Add validation that step exists and was completed before attempting undo
</how>

<done>
- undo_mac_defaults() function exists in lib/state.sh
- Function validates step was completed before undo
- Can either delete key or restore original value
- Executes defaults delete correctly
- Restarts affected services appropriately
- Updates state to reflect undo operation
- Error handling for common failure cases
</done>

<verify>
```bash
source lib/state.sh

# Setup test state
export KYLDVS_PREFIX="/tmp/test-kyldvs-$$"
init_state_file

# Create mock completed state for a defaults change
jq '.steps += [{"id": "mac-defaults-dock-orientation", "description": "Set dock orientation to left", "kind": "automated", "subtype": "mac-defaults", "status": "completed", "params": {"domain": "com.apple.dock", "key": "orientation", "type": "-string", "value": "left", "original_value": "bottom"}}]' "$KYLDVS_PREFIX/state.json" > "$KYLDVS_PREFIX/state.json.tmp"
mv "$KYLDVS_PREFIX/state.json.tmp" "$KYLDVS_PREFIX/state.json"

# Test that function exists
if declare -f undo_mac_defaults > /dev/null; then
  echo "undo_mac_defaults function exists"
fi

# Test error handling for non-existent step
if ! undo_mac_defaults "com.nonexistent.domain" "nonkey"; then
  echo "Correctly fails for non-existent setting"
fi

# Cleanup
rm -rf "$KYLDVS_PREFIX"
```
</verify>
</task>

<task id="5" type="auto">
<what>Add comprehensive error handling and logging to all undo functions</what>

<why>Users need clear feedback when undo operations fail or succeed</why>

<how>
1. Add common error handling patterns to all undo functions:
   - Check if jq is available (required for state operations)
   - Check if state file exists and is readable
   - Check if step exists in state
   - Check if step status is "completed" (can't undo incomplete steps)
   - Check if undo would leave system in inconsistent state
2. Add logging functions:
   - log_undo_info() for informational messages
   - log_undo_warn() for warnings
   - log_undo_error() for errors
3. Add descriptive error messages for common failures:
   - "Step not found in state"
   - "Step was not completed, cannot undo"
   - "Brew package not installed"
   - "Permission denied"
4. Ensure all error paths return appropriate exit codes
5. Add optional verbose mode for debugging
</how>

<done>
- All undo functions have consistent error handling
- Clear error messages for common failure scenarios
- Logging functions implemented and used throughout
- Exit codes are meaningful and documented
- Verbose mode available for troubleshooting
</done>

<verify>
```bash
source lib/state.sh

# Test logging functions exist
declare -f log_undo_info > /dev/null && echo "log_undo_info exists"
declare -f log_undo_warn > /dev/null && echo "log_undo_warn exists"
declare -f log_undo_error > /dev/null && echo "log_undo_error exists"

# Test error handling
export KYLDVS_PREFIX="/tmp/test-kyldvs-$$"

# Try to undo without state file
if ! undo_brew "test-package" 2>&1 | grep -q "state file"; then
  echo "Error: Should warn about missing state file"
  exit 1
fi

echo "Error handling verified"
```
</verify>
</task>

<task id="6" type="auto">
<what>Create comprehensive unit tests for undo functions</what>

<why>Need to ensure undo functions work correctly and handle edge cases</why>

<how>
1. Create test/lib/test_state_undo.sh test file
2. Implement test cases for each undo function:
   - Test successful undo operation
   - Test undo of non-existent step
   - Test undo of incomplete step
   - Test state update after undo
   - Test error handling for missing dependencies
   - Test concurrent undo operations (if applicable)
3. Use a test framework pattern:
   - Setup: Create temporary state file with mock data
   - Execute: Run undo function
   - Assert: Verify expected outcomes
   - Teardown: Clean up temporary files
4. Mock brew/defaults commands where possible to avoid side effects
5. Document test cases and expected behaviors
</how>

<done>
- test/lib/test_state_undo.sh exists with comprehensive tests
- All undo functions have test coverage
- Tests pass in isolated environment
- Edge cases are covered
- Tests are documented and maintainable
</done>

<verify>
```bash
# Run the test suite
if [ -f test/lib/test_state_undo.sh ]; then
  bash test/lib/test_state_undo.sh
  echo "Test suite executed"
else
  echo "Error: Test file not found"
  exit 1
fi
```
</verify>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. All undo functions exist in lib/state.sh:
```bash
source lib/state.sh
declare -f undo_brew && echo "✓ undo_brew exists"
declare -f undo_brew_cask && echo "✓ undo_brew_cask exists"
declare -f undo_mac_defaults && echo "✓ undo_mac_defaults exists"
```

2. Functions have proper error handling:
```bash
# Should fail gracefully
export KYLDVS_PREFIX="/tmp/nonexistent"
undo_brew "test" 2>&1 | grep -q "state file" && echo "✓ Error handling works"
```

3. State initialization works:
```bash
export KYLDVS_PREFIX="/tmp/verify-$$"
source lib/state.sh
init_state_file
test -f "$KYLDVS_PREFIX/state.json" && echo "✓ State file created"
jq empty "$KYLDVS_PREFIX/state.json" && echo "✓ Valid JSON"
rm -rf "$KYLDVS_PREFIX"
```

4. Tests pass:
```bash
bash test/lib/test_state_undo.sh && echo "✓ All tests pass"
```
</verification>

<success_criteria>
- lib/state.sh exists with all undo functions implemented
- Each undo function can reverse its corresponding setup operation
- Error handling covers common failure scenarios with clear messages
- State file is properly updated after undo operations
- Comprehensive test coverage for all undo functions
- All tests pass successfully
- Functions are documented with usage examples
</success_criteria>

<output>
After completion, create `.planning/phases/04-undo-capability/04-01-SUMMARY.md` documenting:
- Undo functions implemented (brew, brew-cask, mac-defaults)
- Error handling and logging approach
- Test coverage and results
- Any deviations from plan
- Readiness for phase 4 plan 2 (undo command integration)
</output>
